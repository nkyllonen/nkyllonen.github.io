<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Online Portfolio for Nikki Kyllonen</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/mystyle.css" rel="stylesheet">
  <!-- <link rel="stylesheet" href="node_modules/highlight.js/styles/default.css">
  <script src="/path/to/highlight.pack.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> -->

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="index.html">
      <span class="d-block d-lg-none">Nikki Kyllonen</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="img/gradpic-cropped.png" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent"
            aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#about">About</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#hw1">Balloon Pop</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#hw2">Baby Game Engine</a>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

      <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="about">
        <div class="w-100">
          <h1 class="mb-0">CSCI 8980
            <span class="text-primary">Game Engine Technologies</span>
          </h1>
          <div class="subheading mb-5">Professor Stephen Guy · University of Minnesota, Twin Cities · Fall 2019
          </div>
          <p class="lead mb-5">(insert a short description of the class....)</p>
        </div>
      </section>
  
      <hr class="m-0">

      <section class="resume-section p-3 p-lg-5 d-flex justify-content-center" id="hw1">
          <div class="w-100">
            <h2 class="mb-5">Balloon Pop Game</h2>
    
            <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
              <div class="resume-content">
                
                <h3 class="mb-0">HW1 - Game from Scratch</h3>

                <div class="subheading mb-3 social-icons">Source Code:
                  <a href="https://github.com/nkyllonen/8980-balloon-pop">
                    <i class="fab fa-github"></i>
                  </a>
                </div>

                <!-- img-fluid makes images responsive to parent container -->
                <img src="img/8980/hw1-typical.png"
                      id="hw1-fig1" class="img-fluid">
                <p>
                    <b>Figure 1:</b> A typical Level 1 screen.
                </p>

                <div class="subheading mb-3">Gameplay / Game Design</div>
                <p>
                  In this simple game, built in Processing, the player moves the green slider
                  left and right to pop as many colorful balloons as possible and gain the most points.
                  One point is gained for every good colorful balloon, while one point is lost for every
                  evil black balloon that is popped. This score is presented along with the current level
                  in the bottom left corner, as shown in <a href="#hw1-fig1">Figure 1</a>.
                </p>
                <p>
                  As you gain points, you with move onto more difficult levels. Currently,
                  the levels increase one notch for every 10 points earned. Successive levels increase
                  three of the game parameters: maximum balloon spawning speed, slider speed, and the
                  chance a newly spawned balloon will be an evil balloon. Therefore for every new
                  level you face, not only are the balloons harder to pop, the slider is able to
                  travel more quickly. This is the only power-up currently implemented. These values
                  are adjusted as shown below
                  (<a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/pop.pde#L100">
                    pop.pde lines 100-104</a>).
                </p>
                  <pre>
<code class="Processing" id="hw1-code1">
// check score and update level
level = score / 10 + 1;
MAX_SPEED = 150 + level * 10;
brick.speed = 5 + level;
ENEMY_SPAWN_CHANCE = 0.05 + level * 0.05;</code>
                  </pre>
                <p>
                    <b>Snippet 1:</b> Levelup parameter adjustments.
                </p>

                <p>
                  There were quite a few features I had in mind while developing this game. I added to
                  them as I went, but from the beginning, I hashed out two feature lists: basic features
                  and more farfetched features. These I placed into my Trello board, as shown in
                  <a href="#hw1-fig2">Figure 2</a> and <a href="#hw1-fig3">Figure 3</a>.
                </p>
                <p>
                    <img src="img/8980/hw1-basic-features.png"
                    width="500" id="hw1-fig2" class="img-fluid">
                </p>
                <p>
                    <b>Figure 2:</b> Basic features.
                </p>
                <p>
                    <img src="img/8980/hw1-next-features.png"
                    width="500" id="hw1-fig3" class="img-fluid">
                </p>
                <p>
                    <b>Figure 3:</b> More complex features.
                </p>
                <p>
                  The biggest feature I tried to implement for this assignment was the use of a
                  spatial data structure for collision testing (my first task within my "Next
                  Steps" features list above). Despite the goal of using such a structure being
                  to improve performance, after much thought and much work on implementing this
                  feature, I don't believe it would've actually helped improve my gameplay.
                  Although I still wish to pursue this feature, other features that are listed
                  would've more easily accomplished the task of boosting gameplay, such as
                  adding some sort of missiles or more complicated balloon movement.
                </p>

                <p>
                    <img src="img/8980/hw1-pop-sparkles.gif" alt="" class="img-fluid">
                </p>
                <p>
                    <b>Figure 4:</b> The sparkling gif used when good balloons explode.
                    My most fun feature to implement.
                </p>
    
                <div class="subheading mb-3">Algorithmic Discussion</div>
                <p>
                  In developing this game, I allowed my strong Object-Oriented Programming (OOP)
                  tendencies to lead my algorithmic and technical decisions. The strongest example
                  of this is in my (ideally abstract) Object class, shown below
                  (<a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/object.pde">object.pde</a>).
                  This is a stubby container class. There is no functionality and it most probably hurts
                  the overall runtime of the game. However, to myself and other OOP developers, the
                  boost of understanding and organization seems very much worth it when handling
                  the code. Understandability of the code is very much boosted by containers such as
                  Object and its children,
                  <a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/balloon.pde">Balloon</a>
                  and <a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/slider.pde">Slider</a>.
                </p>

                <p>
                  <pre>
<code class="Processing" id="hw1-code2">
class Object {
  // member variables
  PVector position;
  PVector rgb = new PVector(0, 102, 50);
  float speed = 75; // pixels/second
  int lastSpawn = 0;

  Object(PVector pos, int t) {
    position = pos;
    lastSpawn = t;
  }

  void display() {}
}</code>
                  </pre>
                </p>
                <p>
                    <b>Snippet 2:</b> Object class.
                </p>

                <p>
                  From a computational perspective, a bottleneck is my collision testing. Since I
                  am very much aware of the existence of this bottleneck in a majority of graphics
                  programs, I wanted to put some time into building a spatial data structure, as
                  mentioned above. My first approach, and the one which is currently still being
                  used, is a brute force approach. My game loop checks during every frame for
                  collisions between the slider and each balloon, shown in the code snippet below
                  (<a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/pop.pde#L57">
                    pop.pde lines 57-70</a>).
                </p>

                <p>
                  <pre>
<code class="Processing" id="hw1-code3">
// if this balloon collides with the slider
if (b.checkCollision(brick)) {        
  if (!b.evil) {
    animations.add(new Animation(b.position.copy(), popFrames));
    score++;
  }
  else {
    animations.add(new Animation(b.position.copy(), hotFrames));
    score--;
  }

  balloons.remove(i);
  continue;</code>
                  </pre>
                </p>
                <p>
                    <b>Snippet 3:</b> Balloon reaction to collision checking.
                </p>

                <p>
                  After much thought and spending a good amount of time not only considering, but
                  also attempting to integrate a spatial data structure, I decided on a gridding
                  approach which would in a sense, mark which balloons were, at least partially,
                  in which bins. After much work. I was able to accomplish this much. I created
                  a <a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/grid.pde">
                    Grid</a> which knew about which balloons overlapped with which GridCells.
                    However, the more I thought about the complexity, the more I realized that
                    there would not be a performance benefit over my brute force approach. Both
                    methods required iterating over all of the balloons and for the grid approach,
                    there would be extra computation once the grid was built. Because of time
                    constraints and other responsibilities, I chose not to continue working with
                    this gridding approach.
                </p>

                <p>
                  If given more time, instead of using ArrayLists that shrink and grow forever,
                  I would instead use fixed length arrays. ArrayLists, although fun, are not the
                  most efficient because of their conveniently modifiable length. If a max number
                  of balloons was decided upon and I made sure that balloons which were popped
                  or which were lost respawned, therefore in essense living forever, I believe
                  there would be more of a computational improvement than fully implementing
                  and using a gridding system.
                </p>

                <div class="subheading mb-3">Game Engine Analysis</div>
                <p>
                  Although Processing does a good job of being an accessible "gateway" into graphics,
                  an aspect that would've saved me time from the beginning would be something
                  akin to my Object class. Having a pre-built container which knew a bit about
                  how it could be displayed/rendered would've expedited the first few things
                  I did for this assignment, which was build and design my Object and Balloon classes.
                </p>

                <p>
                  Another, more advanced addition, which would have nullified my earlier discussions
                  about collision testing, would be some sort of pre-built collider which understood
                  when it overlapped with other objects. Either this collider itself would already
                  contain collision checking code or another object, a sort of collider manager,
                  would contain the collision algorithms. The collider manager could then be the
                  one that checks to see if it's colliders are overlapping. Since games all require
                  the ability to know if two things are touching (be it if your mouse click landed
                  in the right place or if your character's arrow was able to hit
                  the enemy), a built-in collision system would be incredibly useful for developing
                  games.
                </p>

                <p>
                  In my game specifically, the state is stored within the global variables I declared
                  within my
                  <a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/config.pde">config.pde</a>,
                  as shown below. How these variables interact within my game loop are the core of
                  how this game functions. My game loop can be broken down as follows
                  (<a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/pop.pde#L23">
                  pop.pde lines 23-105</a>):
                  <ol>
                    <li>
                      Determine if I should be displaying a level up splash screen.
                    </li>
                    <li>
                      Determine if I should be spawning new balloons.
                    </li>
                    <li>
                      Loop through every balloon in the world.
                        <ul>
                          <li>
                            Move it. Remove it if it's off the screen. Check if it has collided with
                            the slider. Draw it.
                          </li>
                        </ul>
                    </li>
                    <li>
                      Loop through every animation.
                      <ul>
                          <li>
                            Remove it if it's done. Draw it.
                          </li>
                        </ul>
                    </li>
                    <li>
                      Draw the slider and stats.
                    </li>
                    <li>
                      Check for a level update and adjust accordingly.
                    </li>
                  </ol>
                </p>

                <p>
                  <pre>
<code class="Processing" id="hw1-code4">
// Colors
int BG_COLOR = 100;
int[][] COLORS = {{255,0,0},{102,102,255},{0, 153, 153},{255,102,178},{255,255,0},{102,0,102},{153,0,76}};

// Balloons
int MIN_BALLOONS = 1;
int MAX_SPEED = 150;
int SPAWN_RATE = 700;
int lastSpawn = 0;
ArrayList<Balloon> balloons = new ArrayList<Balloon>();
PImage[] popFrames;
ArrayList<Animation> animations = new ArrayList<Animation>();

// Evil balloons
Balloon[] enemies = new Balloon[5];
float ENEMY_SPAWN_CHANCE = 0.05;
PImage[] hotFrames;

// Spatial Data Struture(s)
//Node root = new Node(width/2.0);
Grid grid;
int GRIDCELL_WIDTH = 100;
int GRIDCELL_HEIGHT = 100;

// Player
Slider brick;
int brickWidth = 50;
int brickHeight = 10;
int score = 0;
int level = 1;
boolean levelUpScreen = false;
int splashStart = 0;</code>
                  </pre>
                </p>
                <p>
                    <b>Snippet 4:</b> Game loop.
                </p>

                <p>
                  During the entire game, and therefore during this game loop, Processing is checking for
                  key press events. These asynchronously interrupt the game to enter the following
                  function within
                  <a href="https://github.com/nkyllonen/8980-balloon-pop/blob/master/pop/action.pde#L5">
                  action.pde</a>, lines 5-10. This asynchronous interruption triggers the slider to
                  check to see if either the left or right arrow keys have been pressed so that
                  the slider's position can be adjusted accordingly.
                </p>

                <p>
                  <pre>
<code class="Processing" id="hw1-code5">
// handle keyboard presses
void keyPressed() {
  if (key == CODED) {
    brick.move(keyCode);
  }
}</code>
                  </pre>
                </p>
                <p>
                    <b>Snippet 5:</b> Key press handler.
                </p>

                <p>
                  The two big "non-moving pieces" are my balloons and animations ArrayLists. As I have already
                  discussed the balloons and they seem fairly self-explanatory, I will wrap this report up
                  by discussing my last feature: incorporating animations (i.e. displaying gifs). I looked
                  to the Processing Tutorial page <a href="https://processing.org/examples/animatedsprite.html">
                  Animated Sprite</a> for code and inspiration.
                </p>

                <p>
                  I started by breaking my gifs into individual frames and storing them globally (popFrames
                  and hotFrames above). When an event occurred which would warrant an animation (the slider
                  colliding with a balloon) a new Animation object would be created at that location and
                  told which frames it needed to display. Therefore, all I needed to do was keep track of
                  which animations were still active drawing frames so that I could draw those frames to
                  the screen. Once all of the frames had been displayed, I then deleted that Animation object.
                  My animations array is therefore almost identical to my balloons array: both contained
                  the active Balloons and Animations so that they could be iterated through and properly
                  rendered.
                </p>

                <div class="subheading mb-3">Preview Video</div>
                <div class="embed-responsive embed-responsive-16by9">
                  <iframe class="embed-responsive-item"
                          src="https://drive.google.com/file/d/1V3-GrU67a5daKnyP_lA3vEmhXPPNxSW-/preview">
                    </iframe>
                </div>

                <div class="subheading mb-3">Screenshots</div>
                <p>
                    <!-- TODO: make these images clickable, so they expand -->
                    <img src="img/8980/hw1-typical.png" width="200" class="img-fluid">
                    <img src="img/8980/hw1-cute-explosion.png" width="200" class="img-fluid">
                    <img src="img/8980/hw1-hot.png" width="200" class="img-fluid">
                </p>

              </div>

              <div class="resume-date text-md-right">
                <span class="text-primary">September 2019</span>
              </div>

              </div>
            </div>
    
          </div>
    
        </section>
      
        <hr class="m-0">

        <section class="resume-section p-3 p-lg-5 d-flex justify-content-center" id="hw2">
          <div class="w-100">
            <h2 class="mb-5">Baby Game Engine</h2>
    
            <div class="resume-item d-flex flex-column flex-md-row justify-content-between mb-5">
              <div class="resume-content">
                
                <h3 class="mb-0">HW2 - Rendering Large Scenes</h3>

                <div class="subheading mb-3 social-icons">Source Code:
                  <a href="https://github.com/nkyllonen/8980-large-scenes">
                    <i class="fab fa-github"></i>
                  </a>

                  <p>fun stuff here</p>

                  <div class="embed-responsive embed-responsive-16by9">
                    <iframe class="embed-responsive-item"
                            src="https://drive.google.com/file/d/1ZdrrtIgAiWb35ReJ9b_xjar0VDjuLQ5L/preview">
                      </iframe>
                  </div>

                </div>
              </div>
            </div>
          </div>
        </section>

        <hr class="m-0">
        
    </div>

    <!-- Bootstrap core JavaScript -->
    <script src="vendor/jquery/jquery.min.js"></script>
    <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>
  
    <!-- Plugin JavaScript -->
    <script src="vendor/jquery-easing/jquery.easing.min.js"></script>
  
    <!-- Custom scripts for this template -->
    <script src="js/resume.min.js"></script>
  
  </body>
  
  </html>